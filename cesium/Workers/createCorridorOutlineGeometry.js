/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.132
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as C}from"./chunk-WWA5PL4H.js";import{a as Q}from"./chunk-B4AA3ARO.js";import"./chunk-XRL4AVS5.js";import"./chunk-U4IEOH5K.js";import{a as J}from"./chunk-GBYLG25F.js";import"./chunk-TCGIRNHN.js";import"./chunk-N4VJKXZS.js";import{b as K}from"./chunk-77IHZJJ3.js";import{a as it}from"./chunk-3W4GT7KQ.js";import"./chunk-G5AGHVVC.js";import"./chunk-DMEY62ID.js";import"./chunk-HTFSEEMT.js";import{a as X}from"./chunk-OFUUQVMR.js";import{a as et}from"./chunk-A56XVLQR.js";import{b as I,c as tt,d as z}from"./chunk-RCV6KWXS.js";import{d as x}from"./chunk-4IW2T6GF.js";import"./chunk-PSPPBZWI.js";import{a as q}from"./chunk-AU7IKHOH.js";import{a as A,d as P,f as $}from"./chunk-64RSHJUE.js";import{a as Y}from"./chunk-3SSKC3VN.js";import"./chunk-OSW76XDF.js";import"./chunk-ED5JPB3S.js";import{b as B}from"./chunk-LEYMRMBK.js";import{e as N}from"./chunk-VTAIKJXX.js";var ot=new A,nt=new A,lt=new A;function ft(t,e){for(let i=0;i<t.length;i++)t[i]=e.scaleToGeodeticSurface(t[i],t[i]);return t}function st(t,e){let i,r,o,s=[],n=t.positions,l=t.corners,a=t.endPositions,h=new et,u=0,p=0,f=0;for(r=0;r<n.length;r+=2)o=n[r].length-3,u+=o,f+=o/3*4,p+=n[r+1].length-3;for(u+=3,p+=3,r=0;r<l.length;r++){i=l[r];let t=l[r].leftPositions;N(t)?(o=t.length,u+=o,f+=o/3*2):(o=l[r].rightPositions.length,p+=o,f+=o/3*2)}let c,d=N(a);d&&(c=a[0].length-3,u+=c,p+=c,c/=3,f+=4*c);let g,m,y,_,b,k,v=u+p,E=new Float64Array(v),P=0,T=v-1,j=c/2,w=X.createTypedArray(v/3,f+4),H=0;if(w[H++]=P/3,w[H++]=(T-2)/3,d){s.push(P/3),k=ot,b=nt;let t=a[0];for(r=0;r<j;r++)k=A.fromArray(t,3*(j-1-r),k),b=A.fromArray(t,3*(j+r),b),C.addAttribute(E,b,P),C.addAttribute(E,k,void 0,T),m=P/3,_=m+1,g=(T-2)/3,y=g-1,w[H++]=g,w[H++]=y,w[H++]=m,w[H++]=_,P+=3,T-=3}let O=0,I=n[O++],S=n[O++];for(E.set(I,P),E.set(S,T-S.length+1),o=S.length-3,s.push(P/3,(T-2)/3),r=0;r<o;r+=3)m=P/3,_=m+1,g=(T-2)/3,y=g-1,w[H++]=g,w[H++]=y,w[H++]=m,w[H++]=_,P+=3,T-=3;for(r=0;r<l.length;r++){let t;i=l[r];let a,h=i.leftPositions,u=i.rightPositions,p=lt;if(N(h)){for(T-=3,a=y,s.push(_),t=0;t<h.length/3;t++)p=A.fromArray(h,3*t,p),w[H++]=a-t-1,w[H++]=a-t,C.addAttribute(E,p,void 0,T),T-=3;s.push(a-Math.floor(h.length/6)),e===Q.BEVELED&&s.push((T-2)/3+1),P+=3}else{for(P+=3,a=_,s.push(y),t=0;t<u.length/3;t++)p=A.fromArray(u,3*t,p),w[H++]=a+t,w[H++]=a+t+1,C.addAttribute(E,p,P),P+=3;s.push(a+Math.floor(u.length/6)),e===Q.BEVELED&&s.push(P/3-1),T-=3}for(I=n[O++],S=n[O++],I.splice(0,3),S.splice(S.length-3,3),E.set(I,P),E.set(S,T-S.length+1),o=S.length-3,t=0;t<S.length;t+=3)_=P/3,m=_-1,y=(T-2)/3,g=y+1,w[H++]=g,w[H++]=y,w[H++]=m,w[H++]=_,P+=3,T-=3;P-=3,T+=3,s.push(P/3,(T-2)/3)}if(d){P+=3,T-=3,k=ot,b=nt;let t=a[1];for(r=0;r<j;r++)k=A.fromArray(t,3*(c-r-1),k),b=A.fromArray(t,3*r,b),C.addAttribute(E,k,void 0,T),C.addAttribute(E,b,P),_=P/3,m=_-1,y=(T-2)/3,g=y+1,w[H++]=g,w[H++]=y,w[H++]=m,w[H++]=_,P+=3,T-=3;s.push(P/3)}else s.push(P/3,(T-2)/3);return w[H++]=P/3,w[H++]=(T-2)/3,h.position=new z({componentDatatype:q.DOUBLE,componentsPerAttribute:3,values:E}),{attributes:h,indices:w,wallIndices:s}}function ct(t){let e=t.ellipsoid,i=C.computePositions(t),r=st(i,t.cornerType),o=r.wallIndices,s=t.height,n=t.extrudedHeight,l=r.attributes,a=r.indices,h=l.position.values,u=h.length,p=new Float64Array(u);p.set(h);let f=new Float64Array(2*u);if(h=K.scaleToGeodeticHeight(h,s,e),p=K.scaleToGeodeticHeight(p,n,e),f.set(h),f.set(p,u),l.position.values=f,u/=3,N(t.offsetAttribute)){let e=new Uint8Array(2*u);if(t.offsetAttribute===J.TOP)e=e.fill(1,0,u);else{let i=t.offsetAttribute===J.NONE?0:1;e=e.fill(i)}l.applyOffset=new z({componentDatatype:q.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let c,d=a.length,g=X.createTypedArray(f.length/3,2*(d+o.length));g.set(a);let A,m,y=d;for(c=0;c<d;c+=2){let t=a[c],e=a[c+1];g[y++]=t+u,g[y++]=e+u}for(c=0;c<o.length;c++)A=o[c],m=A+u,g[y++]=A,g[y++]=m;return{attributes:l,indices:g}}function M(t){t=t??$.EMPTY_OBJECT;let e=t.positions,i=t.width;B.typeOf.object("options.positions",e),B.typeOf.number("options.width",i);let r=t.height??0,o=t.extrudedHeight??r;this._positions=e,this._ellipsoid=P.clone(t.ellipsoid??P.default),this._width=i,this._height=Math.max(r,o),this._extrudedHeight=Math.min(r,o),this._cornerType=t.cornerType??Q.ROUNDED,this._granularity=t.granularity??Y.RADIANS_PER_DEGREE,this._offsetAttribute=t.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+e.length*A.packedLength+P.packedLength+6}M.pack=function(t,e,i){B.typeOf.object("value",t),B.typeOf.object("array",e),i=i??0;let r=t._positions,o=r.length;e[i++]=o;for(let s=0;s<o;++s,i+=A.packedLength)A.pack(r[s],e,i);return P.pack(t._ellipsoid,e,i),i+=P.packedLength,e[i++]=t._width,e[i++]=t._height,e[i++]=t._extrudedHeight,e[i++]=t._cornerType,e[i++]=t._granularity,e[i]=t._offsetAttribute??-1,e};var rt=P.clone(P.UNIT_SPHERE),v={positions:void 0,ellipsoid:rt,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};M.unpack=function(t,e,i){B.typeOf.object("array",t),e=e??0;let r=t[e++],o=new Array(r);for(let f=0;f<r;++f,e+=A.packedLength)o[f]=A.unpack(t,e);let s=P.unpack(t,e,rt);e+=P.packedLength;let n=t[e++],l=t[e++],a=t[e++],h=t[e++],u=t[e++],p=t[e];return N(i)?(i._positions=o,i._ellipsoid=P.clone(s,i._ellipsoid),i._width=n,i._height=l,i._extrudedHeight=a,i._cornerType=h,i._granularity=u,i._offsetAttribute=-1===p?void 0:p,i):(v.positions=o,v.width=n,v.height=l,v.extrudedHeight=a,v.cornerType=h,v.granularity=u,v.offsetAttribute=-1===p?void 0:p,new M(v))},M.createGeometry=function(t){let e=t._positions,i=t._width,r=t._ellipsoid;e=ft(e,r);let o=it(e,A.equalsEpsilon);if(o.length<2||i<=0)return;let s,n=t._height,l=t._extrudedHeight,a=!Y.equalsEpsilon(n,l,0,Y.EPSILON2),h={ellipsoid:r,positions:o,width:i,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!1};if(a)h.height=n,h.extrudedHeight=l,h.offsetAttribute=t._offsetAttribute,s=ct(h);else{let e=C.computePositions(h);if(s=st(e,h.cornerType),s.attributes.position.values=K.scaleToGeodeticHeight(s.attributes.position.values,n,r),N(t._offsetAttribute)){let e=s.attributes.position.values.length,i=t._offsetAttribute===J.NONE?0:1,r=new Uint8Array(e/3).fill(i);s.attributes.applyOffset=new z({componentDatatype:q.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}let u=s.attributes,p=x.fromVertices(u.position.values,void 0,3);return new tt({attributes:u,indices:s.indices,primitiveType:I.LINES,boundingSphere:p,offsetAttribute:t._offsetAttribute})};var Z=M;function ht(t,e){return N(e)&&(t=Z.unpack(t,e)),t._ellipsoid=P.clone(t._ellipsoid),Z.createGeometry(t)}var Ot=ht;export{Ot as default};